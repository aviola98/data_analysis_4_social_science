---
title: "Desafio_5_Viola"
author: "André Viola"
date: "6/18/2021"
output: 
  html_document:
    df_print: paged
---

```{r, echo=FALSE}
#limpando o documento html final
knitr::opts_chunk$set(echo=FALSE,error=FALSE,warning=FALSE,message=FALSE)
```

```{r}
#abrindo os pacotes necessários
library(geobr)
library(tidyverse)
library(tidylog)
library(crul)
library(purrr)
library(readxl)
library(sf)
library(broom)
library(Zelig)
```

>Análise espacial

```{r include=FALSE}
#acessando os municípios do estado de São Paulo em 2018
SP_municipalities <-
  read_municipality(code_muni="SP",year=2018)
```

```{r include=FALSE}
#usando a funcionalidade da família map para aplicar a função read_municipality para SP,RJ,MT,RS e RN (para o ano de 2018)

estados <- c("SP","RJ","MT","RS","RN")
SP_RJ_MT_RS_RN_municipalities <- estados %>%
  map(read_municipality, 2018)
```

```{r}
#abrindo os dados da população de São Paulo em 2010

total_populacao_SP <- read_excel("total_populacao_sao_paulo.xls")
```

```{r}
#cruzando o banco da população com o banco das fronteiras dos municipios de SP

#mudando o código do municipio para dbl
total_populacao_SP[,c(1)]<- sapply(total_populacao_SP[,c(1)],as.numeric)

#mudando a variável "código do município" e "Nome do município" para "code_muni" e "name_muni" respectivamente, com a finalidade de realizar o join uma vez que estas são as chaves 

total_populacao_SP <- total_populacao_SP %>%
  rename("code_muni"="Código do município",
         "name_muni"="Nome do município")

SP_join <- SP_municipalities %>%
  left_join(total_populacao_SP, c("code_muni",
                                 "name_muni"))
```

```{r}
#calculando a proporção da população urbana total em cada município 
SP_join <- SP_join %>%
  mutate(Proporcao_total_urbano=100*(`Total da população urbana`/`Total da população 2010`))
```

```{r}
#apresentando os resultados em um mapa
SP_join %>%
  st_as_sf(coords=c("geom")) %>%
  ggplot() +
  geom_sf(aes(fill=Proporcao_total_urbano))+
  ggtitle("Mapa da proporção da população urbana com relação à população total") +
  theme_minimal()
```

> Testes estatísticos e regressões

```{r}
#teste de Shapiro para avaliar se a taxa de urbanização do município é distribuida de forma normal 

#removendo notação científica
options(scipen=999)
teste_de_normalidade <- SP_join %>%
  pull(Proporcao_total_urbano) %>%
  shapiro.test() %>%
  tidy()
teste_de_normalidade
```

O teste de Shapiro-Wilk de normalidade da Taxa de urbanização do município (Proporcao_total_urbano) tem um valor 'p' de `r teste_de_normalidade %>% pull(p.value) %>% round(3)`, indicando que tem pouca chance da distribuição ser normal para esta variável.

```{r}
#executando uma regressão linear para avaliar se a taxa de urbanização do município (variável dependente) é associada com a população total do município (variável independente).

linear_regression <- SP_join %>%
  lm(Proporcao_total_urbano~`Total da população 2010`,
     data=.) %>%
  tidy()

linear_regression
```

```{r}
#gráfico do efeito marginal(o coeficiente) da variável da população na regressão anterior e o IC do coeficiente

linear_regression %>%
  #calculando o IC
  mutate(conf.lo=estimate-1.96*std.error,
         conf.hi=estimate+1.96*std.error) %>%
  filter(term!="(Intercept)") %>%
  ggplot() +
  geom_point(aes(x=term,y=estimate))+
  geom_errorbar(aes(x=term,y=estimate,ymin=conf.lo,ymax=conf.hi), width=0.1)+
  geom_hline(yintercept=0,lty=2)+
  theme_minimal()+
  ggtitle("Gráfico de Efeito Marginal da variável População")
```

>Análise de Texto
